<!--
 * @Description: 
 * @Version: 1.0
 * @Author: DaLao
 * @Email: dalao_li@163.com
 * @Date: 2021-12-06 21:07:46
 * @LastEditors: DaLao
 * @LastEditTime: 2021-12-06 21:55:38
-->

## 堆

堆通常是一个可以被看做一棵树的数组对象，满足下列性质

最小堆，父结点小于其子结点的值

最大堆，父结点大于其子结点的值

堆总是一棵完全二叉树

## 实现

![](https://cdn.hurra.ltd/img/20211206214509.png)

用数组$a[]$存储该二叉树

![](https://cdn.hurra.ltd/img/20211206214958.png)

对第i个父节点下标为 (i - 1)/2

其左儿子下标为 2 * i + 1，右儿子下标为 2 * i +2

例如父节点28,其下标为3，左儿子19的下标为7，右儿子17下标为8

## 堆排序

```c++
// 调整为小根堆函数
// start,end 表示待建堆区间
template<class T>
void siftDown(vector<T> &v,int start,int end) {
	int parent = start;
	int child = 2*parent + 1;
	// temp暂存子树根节点
	int temp = v[parent];
	// 如果左儿子编号未到终点
	while(child < end) {
		// 如果右儿子比左儿子小
		if(child + 1 < end && v[child] < v[child+1]) {
			// child变为右儿子
			child++;
		}
		//  如果根节点比儿子节点小,则不需要调整
		if(temp >= v[child]) {
			break;
		}
		// 否则需调整儿子和双亲的位置
		v[parent] =  v[child];
		// 儿子上移变为双亲
		parent = child;
		child = 2*child + 1;
	}
	v[parent] = temp;
}

// 堆排序函数
template<class T>
void heapSort(vector<T> v) {
	for(int i =  (v.size()-2)/2; i>=0 ; i-- ) {
		// 建立一个小根堆
		siftDown(v,i,len);
	}
	for(int i = len-1 ; i>0 ; i--) {
		// 交换根和最后一个元素,
		swap(v[0],v[i]);
		siftDown(v,0,i);
	}
}
```