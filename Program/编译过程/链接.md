<!--
 * @Description: 
 * @Version: 1.0
 * @Author: daLao
 * @Email: dalao@xxx.com
 * @Date: 2022-10-03 21:04:57
 * @LastEditors: daLao
 * @LastEditTime: 2022-10-03 23:50:18
-->

## 链接

链接(Linking)是通过`符号`将各个模块组合成一个独立的程序的过程

链接的主要内容就是把各个模块之间的相互引用部分处理好, 使得各个模块能够正确地衔接


### 链接器

假设一个程序有两个模块 main.c 和 module.c, 在 module.c 中定义了函数 func(), 并在 main.c中进行了调用

所有模块被编译成一个可执行文件后, 每一处对 func() 函数的调用都会被替换为一个绝对地址

由于各模块单独编译, 编译器在处理 main.c 时并不知道 func() 的地址, 所以需要把这些调用 func() 的指令的目标地址搁置, 等到最后链接的时候再由链接器对这些地址修正

- 手动修正

若没有链接器, 则必须手工修正 func() 的地址, 当 module.c 被修改并重新编译时, func() 的地址极有可能改变, 那么在 main.c 中所有使用到 func() 函数的地方, 都要全部重新调整地址, 工作相当繁琐

- 链接器修正

通过链接器, 就可以直接调用其他模块中的函数而无需知道它们的地址, 因为链接时链接器会根据符号 func 自动去 module.c 模块查找 func 的地址, 然后将 main.c 模块中所有使用到 func 的指令重新修正, 让它们的目标地址成为真正的 func() 函数的地址


#### 静态链接

在程序运行之前确定符号地址的过程为静态链接(Static Linking)


#### 动态链接

要等到程序运行期间再确定符号地址的过程为动态链接(Dynamic Linking)

Windows 下的 .dll 或 Linux 下的 .so 必须要嵌入到可执行程序, 作为可执行程序的一部分运行, 它们所包含的符号的地址就是在程序运行期间确定的, 所以称为动态链接库(Dynamic Linking Library)


### 符号

函数和变量在本质上都是地址的助记符, 在链接过程中称为`符号`(Symbol)

符号的信息, 包括当前符号在字符串表中的偏移、符号在段中的偏移、符号所占用的字节数、符号类型等


#### 符号表

目标文件中符号表(Symbol Value), 段名为`.symtab`, 记录文件中用到的所有符号, 包括

符号表记录了当前目标文件用到的所有符号, 包括

- 全局符号, 即函数和全局变量, 可以被其他目标文件引用

- 外部符号(External Symbol), 即在当前文件中使用到、却没有在当前文件中定义的全局符号

- 局部符号, 即局部变量, 只在函数内部可见, 对链接过程没有作用, 所以链接器往往忽略处理

- 段名, 往往由编译器产生, 它的值就是该段的起始地址, 如.text、.data等


#### 重定位

链接器的原理是找到`符号`的地址, 或者把指令中使用到的地址加以修正, 此过程称为符号决议(Symbol Resolution)或者重定位(Relocation)


例如在 a.c 中有一个 int 类型的全局变量 var, 在 b.c 中对它赋值 42

```c
int32_t var = 42;
```

对应的汇编代码

```c
mov 0x2a, var
```

mov 用来将一份数据移动到一个存储位置, 这里表示将 0x2a 移动到 var 符号所代表的位置, 也就是对 var 变量赋值

当被编译成目标文件后, 得到机器指令

```c
c705  00000000  0000002a
```

由于编译时不知道变量 var 的地址, 编译器将这条 mov 指令的目标地址设置为 0, 等到将目标文件 a.o 和 b.o 链接时, 再由链接器修正

假设生成可执行文件后变量 var 的地址为 0x1100, 则机器指令变为

```c
c705  00001100  0000002a
```

这种地址修正的过程就是重定位, 每个需要被修正的地方叫做一个重定位入口(Relocation Entry)

重定位所做的工作就是给程序中每个这样的绝对地址引用的位置修正, 使它们指向正确的地址




