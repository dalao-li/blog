<!--
 * @Description: 
 * @Version: 1.0
 * @Author: DaLao
 * @Email: dalao_li@163.com
 * @Date: 2021-02-16 23:46:39
 * @LastEditors: DaLao
 * @LastEditTime: 2022-01-13 11:20:49
-->

## 静态分配

栈内存是由编译器自动分配与释放

例如函数中声明一个 int 类型的变量i时，编译器会自动开辟一块内存存放变量 i，其生存周期只在函数运行过程中，运行后即释放，并不可再次访问

## 动态分配  

由 alloca 函数分配

堆内存完全由程序员手动申请与释放

程序员使用内存分配函数(如 malloc 函数)来申请任意多少的内存，使用完再由程序员负责使用内存释放函数(如 free 函数)释放内存

```c
// 分配堆内存
char *p1 = (char *)malloc(4);

// 释放堆内存
free(p1);
p1=NULL;
```

对栈内存的自动释放而言，虽然堆上的数据只要程序员不释放空间就可以一直访问，但是如果一旦忘记了释放堆内存，那么将会造成内存泄漏，导致程序出现致命的潜在错误

## 碎片

对堆来说，频繁分配和释放不同大小的堆空间会造成内存空间的不连续，从而产生大量碎片，导致程序效率降低

对栈来讲则不存在这个问题

##  效率

栈是机器系统提供的数据结构，计算机在底层对栈提供支持

如分配专门的寄存器存放栈的地址，压栈出栈都有专门的执行指令，所以栈的效率较高

一般而言，只要栈的剩余空间大于所申请空间，系统就将为程序提供内存，否则将报异常提示栈溢出

堆是由 C/C++ 函数库提供，为分配一块堆内存，操作系统有一个记录空闲内存地址的链表，当系统收到程序申请时会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序

对于大多数系统，会在这块内存空间的首地址处记录本次分配的大小，这样 delete 语句才能正确释放本内存空间

另外，由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动将多余的那部分重新放入空闲链表中，堆的分配效率比栈要低得多


## 申请大小限制

栈是一块连续的内存区域

地址的增长方向向下(内存地址减小的方向)进行，栈顶的地址和栈的最大容量一般由系统预先规定好，如果申请的空间超过栈的剩余空间时，会提示溢出错误.所以相对于堆，能够从栈中获得的空间相对较小

操作系统用链表来存储空闲内存地址(内存区域不连续)，链表的遍历方向由`低地址向高地址`进行

因此，堆内存的申请大小受限于计算机系统中有效的虚拟内存.


## 存储的内容

栈一般用于存放函数参数与局部变量等

函数调用时，第一个进栈的是主函数中调用处的下一条指令(即函数调用语句的下一条可执行语句)的地址，然后是函数的各个参数，在大多数 C 编译器中，参数是由右往左入栈的，最后是函数中的局部变量(注意 static 变量是不入栈的).

当本次函数调用结束后，遵循"**先进后出**"的规则，局部变量先出栈，然后是参数，最后栈顶指针指向最开始保存的地址，也就是主函数中的下一条指令，程序由该点继续运行.  
下面的示例代码可以清晰反映这种入栈顺序:
```c
void f(int i){
    printf("%d,%d,%d,%d\n",i,i++,i++,i++);
}

int main(void){
    int i = 1;
    f(i);
    return 0;
}
```
由于栈的"先进后出"规则，所以程序最后的输出结果是"4，3，2，1".

堆具体存储内容由程序员根据需要决定.
