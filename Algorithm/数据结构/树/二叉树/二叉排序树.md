## 二叉排序树

### 概念

二叉排序树Binary Sort Tree(BST)，也称二叉查找树,为非空树时有如下特点

- 若左子树非空，则左子树上所有结点值均`小于`其根结点值

- 若右子树非空，则右子树上所有结点值均`大于`其根结点值

- 其左、右子树也是二叉排序树

- 没有键值相等结点

![](https://cdn.hurra.ltd/img/20200713145026.png)

对该树进行中序遍历(LDR)得到， 9，11，23，45，58，76

中序遍历二叉排序树时会得到一个递增的有序序列


### 查找

- 二叉树非空时，查找根结点，若值相等则查找成功

- 若不相等

  当值小于根结点值时，查找左子树
  
  大于根结点值时，查找右子树

- 查找到叶节点仍未找到，查找失败

![](https://cdn.hurra.ltd/img/20200713145026.png)

查找 $23$

因为`23<45`则查找左子树

因为`23>11`则查找右子树

`23=23`则查找成功  

查找 $47$

因为`47<45`则查找右子树

因为`47<58`则查找左子树

左子树为空，查找失败


## 代码

### 节点定义

```c++
template<class T>
struct BSTNode{
    T value;
    BSTNode<T> *leftSon;
    BSTNode<T> *rightSon;

    BSTNode(T value， BSTNode<T> *leftSon， BSTNode<T> *rightSon{
        this->value = value;
        this->leftSon = leftSon;
        this->rightSon = rightSon;
    }
};
```

### 查找

```c++
// 递归写法
template<class T>
BSTNode<T> *searchBST(BSTNode<T> *root,T value){
    if(root == nullptr){
        return nullptr;
    }
    if(root->value == value){
        return root;
    }
    if(root->value > value){
        return searchBST(root->lchind,value);
    }
    if(root->value < value){
        return searchBST(root->rchind,value);
    }
}

// 非递归写法
template<class T>
BSTNode<T> *searchBST(BSTNode<T> *root，T value){
    while(root){
        if(root->value == value){
            return root;
        }
        if(root->value > value){
            root = root->lchind;
        }
        if(root->value < value){
            root = root->rchind;
        }
    }
    return nullptr;
}
```

### 插入

- 若二叉排序树为空，直接插入结点

- 若二叉排序树非空，当值`小于`根结点时，插入`左子树`;当值`大于`根结点时，插入`右子树`

- 若等于根结点时不进行插入

新插入的结点总是`叶子结点`

![](https://cdn.hurra.ltd/img/20200713151801.png)

插入 15 ，因为`15<45`则选择左子树，因为`15>11`则选择右子树;`15<23`则选择左子树，左子树为空，则插入

```c++
// 返回构建完成后的根节点
template<class T>
BSTNode<T> *insertBST(BSTNode<T> *root，T value){
    // 节点为空，说明是叶子节点
    if(root == nullptr){
        root = new BSTNode<T>(value，nullptr，nullptr);
        return root;
    }
    // 值小于根结点时，插入根节点的左子树
    if(root->value > value){
        root->leftSon = insertBST(root->leftSon，value);
    }
    // 值大于根结点时，插入根节点的右子树
    if(root->value < value){
        root->rightSon = insertBST(root->rightSon，value);
    }
    return root;
}
```

### 构建

```c++
// 使初始根节点为空，进行插入操作
template<class T>
void createBST(BSTNode<T> *&root，vector<T> v){
    for(int i = 0; size = v.size(); i < size; i++){
        root = insertBST(root，v[i]);
    }
}
```


### 删除

- 叶子结点可以直接删除
  
- 若被删除的结点 $x$ 只有一个子树，则让 $x$ 的子树成为 $x$ 父结点的子树，代替 $x$ 结点

- 若被删除的结点 $x$ 有两个子树，则让 $x$ 的右子树中最小节点代替 $x$，并删除最小节点

![](https://cdn.hurra.ltd/img/20200713145026.png)


删除 9，由于 9 是叶子节点，则直接删除

![](https://cdn.hurra.ltd/img/20200713160057.png)

删除 58，由于 58 节点只有一个子树，则让 58 的子树 76，成为 58 的父节点 45 的子树

![](https://cdn.hurra.ltd/img/20200713160434.png)


删除 11，11 的右子树中最小节点为 23，则让 23 代替 11

![](https://cdn.hurra.ltd/img/20200713161254.png)

![](https://cdn.hurra.ltd/img/20200713161320.png)

```c++
template<class T>
void deleteBST(BSTNode<T> *&root，T value){
    if(root == nullptr){
        return;
    }
    //p为待删除节点，fp为其父节点
    BSTNode<T> *fp，*p = root;
    while(p->value != value){
        if(p->value > value){
            fp = p;
            p = p->leftSon;
        }
        if(p->value < value){
            fp = p;
            p = p->rightSon;
        }
    }
    // 情况1:p为叶子节点直接删
    if(p->leftSon == nullptr && p->rightSon == nullptr){
        if(fp->leftSon != nullptr){
            fp->leftSon = nullptr;
        }
        if(fp->rightSon != nullptr){
            fp->rightSon = nullptr;
        }
        delete(p);
        return;
    }
    // 情况2:p左子树为空则重接右子树
    else if(p->leftSon == nullptr){
        p->value = p->rightSon->value;
        p->rightSon = nullptr;
        delete(p);
        return;
    }
    // 情况3:p右子树为空则重接左子树
    else if(p->rightSon == nullptr){
        p->value = p->leftSon->value;
        p->leftSon = nullptr;
        delete(p->leftSon);
        return;
    }
    // 情况4:p左右子树均不为空时，需要找p右子树中最小节点(最左节点)q
    BSTNode<T> *q = p->rightSon;
    // s为q的父节点
    BSTNode<T> *s = q;
    // 循环查找左节点，就会找到最小值
    while(q->leftSon != nullptr){
        s = q;
        q = q->leftSon;
    }
    s->leftSon = nullptr;
    // 用最小值节点代替欲删除节点
    p->value = q->value;
    delete(q);
}
```

### 遍历

```c++
// 采取中序遍历的方式
template<class T>

void outputBST(BSTNode<T> *root){
    if(root->leftSon != nullptr){
        outputBST(root->leftSon);
    }

    cout<<root->value<<"== ";

    if(root->rightSon != nullptr){
        outputBST(root->rightSon);
    }
}
```

![](https://cdn.hurra.ltd/img/20200714234856.png)


```c
#include<iostream>
#include<vector>

using namespace std;

// 节点定义
template<class T>
struct BSTNode {
    T value;
    BSTNode<T> *leftSon;
    BSTNode<T> *rightSon;
    BSTNode(T value,BSTNode<T> *leftSon,BSTNode<T> *rightSon){
        this->value = value;
        this->leftSon = leftSon;
        this->rightSon = rightSon;
    }
};

//查找
template<class T>
BSTNode<T> *searchBST(BSTNode<T> *&root,T value){
    if(root == nullptr){
        return nullptr;
    }
    if(root->value == value){
        return root;
    }
    if(root->value > value){
        return searchBST(root->leftSon,value);
    }
    if(root->value < value){
        return searchBST(root->rightSon,value);
    }
}


// 插入
template<class T>
BSTNode<T> *insertBST(BSTNode<T> *&root,T value){
    //当前节点为空,说明是叶子节点,可以插入
    if(root == nullptr){
        root = new BSTNode<T>(value,nullptr,nullptr);
        return root;
    }
    //值小于根结点时,插入根节点的左子树
    if(root->value > value){
        root->leftSon = insertBST(root->leftSon,value);
    }
    //值大于根结点时,插入根节点的右子树
    if(root->value < value){
        root->rightSon = insertBST(root->rightSon,value);
    }
    return root;
}

// 构建
template<class T>
void createBST(BSTNode<T> *&root,vector<T> v){
    for(int i = 0,size = v.size();i < size;i++){
        root = insertBST(root,v[i]);
    }
}

// 遍历
template<class T>
void outputBST(BSTNode<T> *&root){
    if(root == nullptr){
        return;
    }
    outputBST(root->leftSon);
    cout<<root->value<<" ";
    outputBST(root->rightSon);
}

// 删除
template<class T>
void deleteBST(BSTNode<T> *&root,T value){
    if(root == nullptr){
        return;
    }
    // p为待删除节点,fp为其父节点
    BSTNode<T> *fp,*p = root;
    while(p->value != value){
        if(p->value > value){
            fp = p;
            p = p->leftSon;
        }
        if(p->value < value){
            fp = p;
            p = p->rightSon;
        }
    }
    // 情况1:p为叶子节点直接删
    if(p->leftSon == nullptr && p->rightSon == nullptr){
        if(fp->leftSon != nullptr){
            fp->leftSon = nullptr;
        }
        if(fp->rightSon != nullptr){
            fp->rightSon = nullptr;
        }
        delete(p);
        return;
    }
    //情况2:p左子树为空则重接右子树
    if(p->leftSon == nullptr){
        p->value = p->rightSon->value;
        p->rightSon = nullptr;
        delete(p);
        return;
    }
    //情况3:p右子树为空则重接左子树
    if(p->rightSon == nullptr){
        p->value = p->leftSon->value;
        p->leftSon = nullptr;
        delete(p->leftSon);
        return;
    }
    //情况4:p左右子树均不为空时,需要找p右子树中最小节点(最左节点)q
    BSTNode<T> *q = p->rightSon;
    //s为q的父节点
    BSTNode<T> *s = q;
    //循环查找左节点,就会找到最小值
    while(q->leftSon != nullptr){
        s = q;
        q = q->leftSon;
    }
    s->leftSon = nullptr;
    //用最小值节点代替欲删除节点
    p->value = q->value;
    delete(q);
}

int main(int argv,char *argc[]) {
    vector<int> v = {11,45,9,23,76,58};

    BSTNode<int> *root = nullptr;
    createBST(root,v);
    cout<<"二叉排序树的中序遍历结果: ";
    outputBST(root);
    cout<<endl;

    // 插入值
    int newNode = 35;
    cout<<"插入新值:"<<newNode<<endl;
    root = insertBST(root,newNode);
    cout<<"插入新值后二叉排序树的中序遍历结果: ";
    outputBST(root);
    cout<<endl;

    //删除值
    int delNode = 35;
    cout<<"删除值:"<<delNode<<endl;
    deleteBST(root,delNode);
    cout<<"删除值后二叉排序树的中序遍历结果: ";
    outputBST(root);
    cout<<endl;
}
```/*
 * @Description: 
 * @Version: 1.0
 * @Author: DaLao
 * @Email: dalao_li@163.com
 * @Date: 2021-11-28 14:50:38
 * @LastEditors: DaLao
 * @LastEditTime: 2021-11-28 14:53:54
 */

```c
#include<iostream>
#include<vector>

using namespace std;

// 节点定义
template<class T>
struct BSTNode {
    T value;
    BSTNode<T> *leftSon;
    BSTNode<T> *rightSon;
    BSTNode(T value,BSTNode<T> *leftSon,BSTNode<T> *rightSon){
        this->value = value;
        this->leftSon = leftSon;
        this->rightSon = rightSon;
    }
};

//查找
template<class T>
BSTNode<T> *searchBST(BSTNode<T> *&root,T value){
    if(root == nullptr){
        return nullptr;
    }
    if(root->value == value){
        return root;
    }
    if(root->value > value){
        return searchBST(root->leftSon,value);
    }
    if(root->value < value){
        return searchBST(root->rightSon,value);
    }
}


// 插入
template<class T>
BSTNode<T> *insertBST(BSTNode<T> *&root,T value){
    //当前节点为空,说明是叶子节点,可以插入
    if(root == nullptr){
        root = new BSTNode<T>(value,nullptr,nullptr);
        return root;
    }
    //值小于根结点时,插入根节点的左子树
    if(root->value > value){
        root->leftSon = insertBST(root->leftSon,value);
    }
    //值大于根结点时,插入根节点的右子树
    if(root->value < value){
        root->rightSon = insertBST(root->rightSon,value);
    }
    return root;
}

// 构建
template<class T>
void createBST(BSTNode<T> *&root,vector<T> v){
    for(int i = 0,size = v.size();i < size;i++){
        root = insertBST(root,v[i]);
    }
}

// 遍历
template<class T>
void outputBST(BSTNode<T> *&root){
    if(root == nullptr){
        return;
    }
    outputBST(root->leftSon);
    cout<<root->value<<" ";
    outputBST(root->rightSon);
}

// 删除
template<class T>
void deleteBST(BSTNode<T> *&root,T value){
    if(root == nullptr){
        return;
    }
    // p为待删除节点,fp为其父节点
    BSTNode<T> *fp,*p = root;
    while(p->value != value){
        if(p->value > value){
            fp = p;
            p = p->leftSon;
        }
        if(p->value < value){
            fp = p;
            p = p->rightSon;
        }
    }
    // 情况1:p为叶子节点直接删
    if(p->leftSon == nullptr && p->rightSon == nullptr){
        if(fp->leftSon != nullptr){
            fp->leftSon = nullptr;
        }
        if(fp->rightSon != nullptr){
            fp->rightSon = nullptr;
        }
        delete(p);
        return;
    }
    //情况2:p左子树为空则重接右子树
    if(p->leftSon == nullptr){
        p->value = p->rightSon->value;
        p->rightSon = nullptr;
        delete(p);
        return;
    }
    //情况3:p右子树为空则重接左子树
    if(p->rightSon == nullptr){
        p->value = p->leftSon->value;
        p->leftSon = nullptr;
        delete(p->leftSon);
        return;
    }
    //情况4:p左右子树均不为空时,需要找p右子树中最小节点(最左节点)q
    BSTNode<T> *q = p->rightSon;
    //s为q的父节点
    BSTNode<T> *s = q;
    //循环查找左节点,就会找到最小值
    while(q->leftSon != nullptr){
        s = q;
        q = q->leftSon;
    }
    s->leftSon = nullptr;
    //用最小值节点代替欲删除节点
    p->value = q->value;
    delete(q);
}

int main(int argv,char *argc[]) {
    vector<int> v = {11,45,9,23,76,58};

    BSTNode<int> *root = nullptr;
    createBST(root,v);
    cout<<"二叉排序树的中序遍历结果: ";
    outputBST(root);
    cout<<endl;

    // 插入值
    int newNode = 35;
    cout<<"插入新值:"<<newNode<<endl;
    root = insertBST(root,newNode);
    cout<<"插入新值后二叉排序树的中序遍历结果: ";
    outputBST(root);
    cout<<endl;

    //删除值
    int delNode = 35;
    cout<<"删除值:"<<delNode<<endl;
    deleteBST(root,delNode);
    cout<<"删除值后二叉排序树的中序遍历结果: ";
    outputBST(root);
    cout<<endl;
}
```
```