<!--
 * @Description: 
 * @Version: 1.0
 * @Author: DaLao
 * @Email: dalao_li@163.com
 * @Date: 2021-01-16 17:59:35
 * @LastEditors: dalao
 * @LastEditTime: 2022-04-01 23:14:56
-->

## 哈夫曼树


### 概念

给定 $N$ 个权值作为 $N$ 个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为哈夫曼树

哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近

| 节点 | 权值 |
| ---- | ---- |
| A    | 12   |
| B    | 24   |
| C    | 35   |
| D    | 67   |
| E    | 46   |
| F    | 55   |

每次从所有节点中选出最小权值节点与次小权值节点，合并

重复操作至所有节点合并为一棵树

![](https://cdn.hurra.ltd/img/2022-3-26-2219.svg)

对建立好的哈夫曼树，所有节点左儿子编为 0，右儿子编为 1，实现对各节点的编码


### 数据定义

```c++
#define LENGTH 6

// 用以进行哈夫曼编码
int code[20];

// 用以保存每个节点的哈夫曼编码
string huffman[LENGTH];

// 权值
int arr[LENGTH] = {12 , 24 , 35 , 67 , 46 , 55};

// 节点
char alph[LENGTH] = {'A' , 'B' , 'C' , 'D' , 'E' , 'F'};

typedef struct Tree {
    // 节点的权值
    int data;
    Tree* leftSon;
    Tree* rightSon;
    Tree(int data,Tree* leftSon , Tree* rightSon){
        this->data = data;
        this->leftSon = leftSon;
        this->rightSon = rightSon;
    }
} Tree , *TreeList;
```

### 构建

```c++
int cmp(TreeList &t1 , TreeList &t2){
    return t1->data <= t2->data;
}

// 建哈夫曼树,返回根节点
TreeList createTree(int &arr[]) {
    vector<TreeList> v;
    for (int i = 0; i < LENGTH; i++) {
        TreeList leat = new Tree(arr[i] , nullptr , nullptr);
        v.push_back(leat);
    }
    TreeList root = nullptr;
    //容器容量大于1说明还未建立完
    while(v.size() > 1){
        //按照节点值从小到达排序
        sort(v.begin() , v.end() , cmp);
        //最小值节点为v0，次小值节点为v1
        root = new Tree(v[0]->data + v[1]->data , v[0] , v[1]);
        //根节点保存到v1
        v[1] = root;
        v.erase(v.begin());
    }
    return root;
}
```


### 编码

```c++
// 根据权值获取下标
int getIndex(int weight){
    for(int i = 0; i < LENGTH; i++){
        if(weight == arr[i]){
            return i;
        }
    }
}

// 递归进行哈夫曼树编码,len是当前树的层数
void huffmanCoding(TreeList &root , int len) {
    if (root == nullptr) {
        return;
    }
    //若到叶子节点
    if (root->leftSon == nullptr && root->rightSon == nullptr) {
        //获取该节点权值对应的字符下标
        int index = getIndex(root->data);
        //保存该字符的哈夫曼编码
        for (int i = 0; i < len; i++) {
            huffman[index].push_back(code[i] + '0');
        }
        return;
    }
    // 否则继续进行哈夫曼编码的操作
    // 左侧分支都记为零
    code[len] = 0;
    huffmanCoding(root->leftSon , len + 1);
    // 右侧分支都记为一
    code[len] = 1;
    huffmanCoding(root->rightSon , len + 1);

}
```

![](https://cdn.hurra.ltd/img/20200715100403.png)


```c++
/*
 * @Description: 
 * @Version: 1.0
 * @Author: DaLao
 * @Email: dalao_li@163.com
 * @Date: 2018-12-4 14:50:38
 * @LastEditors: DaLao
 * @LastEditTime: 2021-11-28 15:08:09
 */

#include <stdio.h>
#include <string.h>
#include <iostream>
using namespace std;

#define LENGTH 6
//用以进行哈夫曼编码
int code[20];
//用以保存哈夫曼编码
string huffman[LENGTH];

int arr[LENGTH] = {12,24,35,67,46,55}; 

char alph[LENGTH] = {'A' , 'B' , 'C' , 'D' , 'E' , 'F'}; 

typedef struct Tree {
    //节点的权值 
    int data;
    Tree* leftChild;
    Tree* rightChild;
} Tree , *TreeList;

// 建哈夫曼树,返回根节点
TreeList createTree(int arr[]) {
    // 建立指针数组用来保存节点信息
    TreeList leaves[LENGTH];
    for (int i = 0; i < LENGTH; i++) {
        TreeList leaf = new Tree;
        leaf->data = arr[i];
        leaf->leftChild = leaf->rightChild = NULL;
        leaves[i] = leaf;
    }
    // 建立一个节点作为哈夫曼树的根节点
    TreeList root = NULL;
    // 建立哈夫曼树 
    for (int i = 1; i < LENGTH; i++) {
        // min1表示最小权值的树根结点的下标,min2为次小权值节点的下标
        int min1 = -1, min2;
        // 初始化min1与min2 
        for (int j = 0; j < LENGTH; j++) {
            if (leaves[j] != NULL && min1 == -1) {
                min1 = j;
                continue;
            }
            if (leaves[j] != NULL) {
                min2 = j;
                break;
            }
        }
        // 找出最小值和次小值节点的下标
        for (int j = min2; j < LENGTH; j++) {
            if (leaves[j] != NULL) {
                if (leaves[j]->data < leaves[min1]->data) {
                    min2 = min1;
                    min1 = j;
                } else if (leaves[j]->data < leaves[min2]->data) {
                    min2 = j;
                }
            }
        }
        // 用最小权值树和次小权值树建立一棵新树,root指向树根结点
        root = new Tree;
        root->data = leaves[min1]->data + leaves[min2]->data;
        root->leftChild = leaves[min1];
        root->rightChild = leaves[min2];
        // 将指向新树的指针赋给leaves指针数组中min1位置
        leaves[min1] = root;
        // min2位置为空
        leaves[min2] = NULL;
    }
    return root;
}

// 根据权值获取下标 
int getIndex(int weight){
    for(int i = 0;i < LENGTH; i++){
        if(weight == arr[i]){
            return i;
        }
    }
} 

// 递归进行哈夫曼树编码,len是当前树的层数
void huffmanCoding(TreeList &root , int len) {
    if (root == NULL) {
        return;
    }
    // 若到叶子节点
    if (root->leftChild == NULL && root->rightChild == NULL) {
        // 获取该节点权值对应的字符下标 
        int index = getIndex(root->data);
        // 保存该字符的哈夫曼编码
        for (int i = 0; i < len; i++) {
            huffman[index].push_back(code[i] + '0');
        }
    }
    // 否则继续进行哈夫曼编码的操作
    else {
        // 左侧分支都记为零
        code[len] = 0;
        huffmanCoding(root->leftChild , len + 1);
        // 右侧分支都记为一
        code[len] = 1;
        huffmanCoding(root->rightChild , len + 1);
    }
}

int main(void) {
    TreeList root = createTree(arr);
    huffmanCoding(root , 0);
    for (int i = 0; i < LENGTH; i++) {
        cout << alph[i] << "的哈夫曼编码是 : " << huffman[i] << endl;
    }
    return 0;
}
```

