## 部分和问题

n 个数中选 k 个数使其和为 sum，求方案数

- 方案一，遍历每一个数，分别搜索选该数与不选该数的情况，选完 n 个数后判断和是否为 sum

```c
// 方案数
int ans;

// n个数
int a[n+1];

// 目标和
int sum;

// i ,选择到了第i个数，
// cnt ,已经选择了几个数
// s ,当前总和
void dfs(int i，int cnt，int s){
    if(s > sum){
        return;
    }
    if(i == n && cnt == k && s == sum){
        ans++;
        return;
    }
    dfs(i+1， cnt， s);
    dfs(i+1， cnt+1， s + a[i])
}
```

- 方案二，建立搜索树，对情况进行搜索

```c
// x[i]，第i个数选择情况，false代表为未选过;true代表选过
bool x[n+1];

// p，下次搜索位置
// cnt，已选择数字个数
// s，当前和
void dfs(int p，int cnt，int s) {
	if(s > sum || cnt > k) {
		return;
	}
	if(cnt == k && s == sum) {
		ans++;
		return;
	}
    // 下次搜索位置为p
	for(int i = p; i <= n; i++) {
		if(!x[i]) {
			x[i] = true;
			dfs(i+1 , cnt + 1 , s + a[i]);
			x[i] = false;
		}
	}
}

dfs(0,0,0);
```

![](https://cdn.hurra.ltd/img/20211115221553.png)

引申问题

n 个数中选若干个数使其和为 sum，相当于类型一问题中不需要做 cnt == k 的判断，其他部分完全一致

## 多重部分和

$n$ 个数字 $a[i](i = {1，2......n})$，每种数字各 $b[i]$个，判断选出若干数和恰好为 $k$ 的方案数

令 $dp[i][j]$ 代表，选择前 $i$ 个数字，使得和为 $j$ 的方案数

$dp[i][j] = \sum_0^k dp[i-1][j-k*a[i]] (k=0，1，2......b[i] 且 k*a[i] <= j)$  

即从选择前$i-1$个数，使得和为$j-k*a[i] (k=0，1，2......b[i])$的状态转移而来

```c
int dp[n+1][k+1];

dp[0][0]=1;
for(int i=1;i<=n;i++){
	for(int j=0;j<=k;j++){
		for(int k=0;k<=b[i] && k*a[i]<=j;k++){
			dp[i][j] +=dp[i-1][j-k*a[i]];
		}
    }
}

dp[n][k];
```
