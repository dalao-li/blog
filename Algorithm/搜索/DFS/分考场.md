<!--
 * @Description: 
 * @Version: 1.0
 * @Author: DaLao
 * @Email: dalao_li@163.com
 * @Date: 2021-01-16 17:59:35
 * @LastEditors: DaLao
 * @LastEditTime: 2022-03-27 00:34:10
-->

![](https://cdn.hurra.ltd/img/20201029134655.png)

## 分析

- 使用 DFS 搜索

- 对每一个人，判断能否给他安排进当前的 n 间教室里,若能则继续搜索下一位

- 若安排不了，则新开一间教室把他安排进去

- 上述两种情况都会出现回溯

### 代码

```c
//记录人员关系，p[x][y] = 1表示x，y认识
int p[101][101];

//记录每个教室里的人数
int cnt[101];

//记录每个教室的安排情况
int room[101][101];

// 表示最大的情况
int ans = 0x7fffffff;

// 参加考试人数
int n;

// m组关系
int m;

// 搜索,将第x个人安排进前num个教室里
void dfs(int x,int num){
	if(num >= ans){
		return;
	}
	// 人员搜索完
	if(x > n){
		ans = ans < num ? ans : num;
		return;
	}
	// 遍历每一个教室中每一个人
	for(int i = 0 ; i < num ; i++){
		bool f = true;
		for(int j = 0;j < cnt[i] ; j++){
			// x和他认识,不能安排x
			if(p[x][room[i][j]] != 0){
				f = false;
				break;
			}
		}
		if(f){
			// 能把x安排到这个教室，x是第i个教室第cnt[i]个人
			room[i][cnt[i]] = x;
			cnt[i]++;
			dfs(x+1 , num);
            // 回溯
			cnt[i]--;
			room[i][cnt[i]] = 0;
		}
	}
	// 全部安排不了，新开个教室,把x放进去
	room[num][0] = x;
	cnt[num]++;
	dfs(x+1,num+1);
	room[num][0] = 0;
	cnt[num]--;
}

int main(){
	int u,v;
	scanf("%d%d" , &n , &m);
	while(m--){
		scanf("%d%d" , &u , &v);
		p[u][v] = 1;
		p[v][u] = 1;
	}
	dfs(1 , 0);
	cout<<ans<<endl;
}
```


