<!--
 * @Description: 
 * @Version: 1.0
 * @Author: DaLao
 * @Email: dalao_li@163.com
 * @Date: 2021-12-01 20:09:43
 * @LastEditors: dalao
 * @LastEditTime: 2022-04-01 23:16:42
-->

## 最长上升子序列

### 原问题

前 $n$ 个数中最长上升子序列
  
### 子问题

前 $1$ 个数的最长上升子序列...前 $n$ 个数的最长上升子序列

### 中间状态

$dp[i]$代表前 $i$ 范围内的中的最长上升子序列，最终求 $dp[n]$


### 边界值

$dp[1] = 1$


### 状态转移方程

- 状态 $i = 2$，$dp[2] = max(dp[1]，dp[1] + 1)$

![](https://cdn.hurra.ltd/img/20211201202623.png)


- 状态 $i$，$dp[i] = max(dp[i]，dp[j] + 1)$，$j < i$ 且 $a[j] < a[i]$

```c++
memset(dp , 1 , sizeof(dp));

for(int i = 2; i <= n; i++){
    for(int j = 1; j < i; j++){
        if(a[j] < a[i]){
            dp[i] = dp[i] > (dp[j] + 1) ? dp[i] : (dp[j] + 1);
        }
    }
}
```