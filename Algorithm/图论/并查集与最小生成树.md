<!--
 * @Description: 
 * @Version: 1.0
 * @Author: DaLao
 * @Email: dalao_li@163.com
 * @Date: 2021-10-06 13:11:32
 * @LastEditors: dalao
 * @LastEditTime: 2022-04-05 13:39:18
-->

## 1 并查集


### 1.1 初始化

定义 $p[x] = y$，表示$x$的父节点是$y$

```c
void init(int i){
    // 初始状态时i的父节点是其本身
    p[i] = i;
}
```


### 1.2 查询

查询$i$节点的头节点

```c
int find(int i){
    int b = i;
    // 当i的父节点不是它本身时
    while(i != p[i]){
        // 继续向上查找
        i = p[i]
    }
    // 路径压缩
    whlie(b != i){
        // 将查询路径上所有节点的父亲设为i
        p[b] = i;
        b = p[b];
    }
}
```

- 路径压缩

![](https://cdn.hurra.ltd/img/2022-4-4-0111.svg)


### 1.3 合并

合并两个节点$a$，$b$，将$a$父节点设为$b$

```c
void unions(int a , int b){
    int x = find(a);
    int y = find(b);
    if(x != y ){
        p[x] = y;
    }
}
```

![](https://cdn.hurra.ltd/img/2022-4-5-1330.svg)


### 1.4 统计数量

统计并查集中父节点数量

```c
int count(){
    int sum = 0 ;
    for(int i = 0; i < n; i++){
        // 某个节点父节点是自己
        if(i == p[i]){
            sum++;
        }
    }
    return sum;
}
```

![](https://cdn.hurra.ltd/img/2022-4-5-1335.svg)



## 2 最小生成树

使用 kruskal 法求最小生成树

![](https://cdn.hurra.ltd/img/2022-4-4-0122.svg)
- C++

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int MAXZ = 10005;
const int n = 6;

typedef struct Edge {
    int u;
    int v;
    int w;
    Edge() {}
    Edge(int s , int e , int w):u(s) , v(e) , w(w) {}
} Edge;

int p[MAXZ];

int a[6] = {0,1,2,3,4,5};

int cmp(Edge &e1 , Edge &e2) {
    return e1.w <= e2.w;
}

vector<Edge> edge;

// 记录所选边的信息
vector<Edge> info;


int kruskal() {
    for(int i = 0; i < n; i++) {
        p[i] = i;
    }
    sort(edge.begin() , edge.end() , cmp);
    // 记录最小生成树权值
    int sum = 0;
    for (int i = 0; i < edge.size(); i++) {
        int u = edge[i].u;
        int v = edge[i].v;
        if (find(u) != find(v)) {
            sum += edge[i].w;
            unions(u , v);
            info.push_back(edge[i]);
        }
    }
    return sum;
}

int find(int i) {
    int b = i;
    while(i!=p[i]) {
        i = p[i];
    }
    while(b!=i) {
        p[b] = i;
        b = p[b];
    }
    return i;
}

void unions(int a , int b) {
    int x = find(a);
    int y = find(b);
    if(x!=y) {
        p[x] = y;
    }
}

int kruskal() {
    for(int i = 0; i < 6; i++) {
        p[i] = i;
    }
    sort(edge.begin() , edge.end() , cmp);
    // 记录最小生成树权值
    int sum = 0;
    for (int i = 0; i < edge.size(); i++) {
        int u = edge[i].u;
        int v = edge[i].v;
        if (find(u) != find(v)) {
            sum += edge[i].w;
            unions(u , v);
            info.push_back(edge[i]);
        }
    }
    return sum;
}

int main(void) {
    Edge e[10];
    e[0] = Edge(1,6,1);
    e[1] = Edge(1,5,16);
    e[2] = Edge(5,6,33);
    e[3] = Edge(6,2,11);
    e[4] = Edge(6,4,14);
    e[5] = Edge(2,4,5);
    e[6] = Edge(1,2,17);
    e[7] = Edge(5,4,4);
    e[8] = Edge(2,3,6);
    e[9] = Edge(3,4,10);
    
    for(int i = 0; i < 10; i++) {
        edge.push_back(e[i]);
    }
    cout << "最小生成树权值为:" << kruskal() << endl;
    for(int i = 0; i < info.size(); i++) {
        printf("选取边:%d---%d 权值为:%d\n" , info[i].u , info[i].v , info[i].w)
    }
    return 0;
}
```

- Python

```py
n = 6

p = [0] * 100

class Edge:
    def __init__(self, u: int, v: int, w: int):
        self.u = u
        self.v = v
        self.w = w

def find(i: int)-> int :
    b = i
    while i != p[i]:
        i = p[i]
    while b != i:
        p[b] = i
        b = p[b]
    return i

def unions(a: int, b: int)-> None:
    x, y = find(a), find(b)
    if x != y:
        p[x] = y

def kruskal(e : list)-> int:
    for i in range(n + 1):
        p[i] = i
    sum = 0
    for i in e:
        if find(i.u) != find(i.v):
            sum += i.w
            unions(i.u, i.v)
    return sum

x = [Edge(1,6,1),Edge(1,5,16),Edge(5,6,33),Edge(6,2,11),Edge(6,4,14),
Edge(2,4,5),Edge(1,2,17),Edge(5,4,4),Edge(2,3,6),Edge(3,4,10)]

# 按照权值排序
y = sorted(x, key = lambda t : t.w)

# 27
print(kruskal(y))
```

![](https://cdn.hurra.ltd/img/20211115225844.png)

![](https://cdn.hurra.ltd/img/2022-4-4-0125.svg)


