<!--
 * @Description: 
 * @Version: 1.0
 * @Author: DaLao
 * @Email: dalao_li@163.com
 * @Date: 2021-10-06 13:11:32
 * @LastEditors: dalao
 * @LastEditTime: 2022-04-01 21:51:21
-->

## 1 并查集


### 1.1 初始化

定义 $p[x] = y$，表示$x$的父节点是$y$

```c
void init(int i){
    // 初始状态时i的父节点是其本身
    p[i] = i;
}
```


### 1.2 查询

查询$i$节点的头节点

```c
int find(int i){
    int b = i;
    // 当i的父节点不是它本身时
    while(i != p[i]){
		// 继续向上查找
        i = p[i]
    }
    // 路径压缩
    whlie(b != i){
        // 将查询路径上所有节点的父亲设为i
        p[b] = i;
        b = p[b];
    }
}
```

![](https://cdn.hurra.ltd/img/20211115222906.png)


### 1.3 合并

合并两个节点$a$，$b$，将$a$父节点设为$b$

```c
void unions(int a , int b){
    int x = find(a);
    int y = find(b);
    if(x != y ){
        p[x] = y;
    }
}
```


### 1.4 统计数量

统计并查集中父节点数量

```c
int count(){
    int sum = 0 ;
    for(int i = 0; i < n; i++){
		// 某个节点父节点是自己
        if(i == p[i]){
            sum++;
        }
    }
    return sum;
}
```

## 2 最小生成树

使用 kruskal 法求最小生成树

![](https://cdn.hurra.ltd/img/20200620201313.png)

- C++

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int MAXZ = 10005;
const int n = 6;

typedef struct E {
	int u; int v; int w;
	E() {}
	E(int s , int e , int w):u(s) , v(e) , w(w) {}
} E;

int p[MAXZ];

int a[6] = {0,1,2,3,4,5};

int cmp(E &e1 , E &e2) {
	return e1.w <= e2.w;
}

vector<E> edge;

// 记录所选边的信息
vector<E> info;


int kruskal() {
	for(int i = 0; i < n; i++) {
		p[i] = i;
	}
	sort(edge.begin() , edge.end() , cmp);
	// 记录最小生成树权值
	int sum = 0;
	for (int i = 0; i < edge.size(); i++) {
		int u = edge[i].u;
		int v = edge[i].v;
		if (find(u) != find(v)) {
			sum += edge[i].w;
			unions(u , v);
			info.push_back(edge[i]);
		}
	}
	return sum;
}

int find(int i) {
	int b = i;
	while(i!=p[i]) {
		i = p[i];
	}
	while(b!=i) {
		p[b] = i;
		b = p[b];
	}
	return i;
}

void unions(int a , int b) {
	int x = find(a);
	int y = find(b);
	if(x!=y) {
		p[x] = y;
	}
}

int kruskal() {
	for(int i = 0; i < 6; i++) {
		p[i] = i;
	}
	sort(edge.begin() , edge.end() , cmp);
	// 记录最小生成树权值
	int sum = 0;
	for (int i = 0; i < edge.size(); i++) {
		int u = edge[i].u;
		int v = edge[i].v;
		if (find(u) != find(v)) {
			sum += edge[i].w;
			unions(u , v);
			info.push_back(edge[i]);
		}
	}
	return sum;
}

int main(void) {
    E e[10];
	e[0] = E(1,6,1);
	e[1] = E(1,5,16);
	e[2] = E(5,6,33);
	e[3] = E(6,2,11);
	e[4] = E(6,4,14);
	e[5] = E(2,4,5);
	e[6] = E(1,2,17);
	e[7] = E(5,4,4);
	e[8] = E(2,3,6);
	e[9] = E(3,4,10);
	for(int i = 0; i < 10; i++) {
		edge.push_back(e[i]);
	}
	cout << "最小生成树权值为:" << kruskal()<<endl;
	for(int i = 0 ; i< info.size(); i++) {
		cout<<"选取边:"<<info[i].u<<"----"<<info[i].v<<" "<<"权值为:"<<info[i].w<<endl;
	}
	return 0;
}
```

- Python

```py
n = 6

p = [0] * 100

class E:
    def __init__(self, u : int, v : int, w : int):
        self.u = u
        self.v = v
        self.w = w

def find(i : int)-> int :
    b = i
    while i != p[i]:
        i = p[i]
    while b != i:
        p[b] = i
        b = p[b]
    return i

def unions(a: int, b: int)-> None:
    x, y = find(a), find(b)
    if x != y:
	    p[x] = y

def kruskal(e : list)-> int:
    for i in range(n + 1):
        p[i] = i
    sum = 0
    for i in e:
        if find(i.u) != find(i.v):
            sum += i.w
            unions(i.u, i.v)
    return sum

x = [E(1,6,1),E(1,5,16),E(5,6,33),E(6,2,11),E(6,4,14),
E(2,4,5),E(1,2,17),E(5,4,4),E(2,3,6),E(3,4,10)]

# 按照权值排序
y = sorted(x, key = lambda t : t.w)

# 27
print(kruskal(y))
```

![](https://cdn.hurra.ltd/img/20211115225844.png)

![](https://cdn.hurra.ltd/img/20200620202155.png)


