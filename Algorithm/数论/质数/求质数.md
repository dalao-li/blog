<!--
 * @Description: 
 * @Version: 1.0
 * @Author: DaLao
 * @Email: dalao_li@163.com
 * @Date: 2021-11-24 22:10:39
 * @LastEditors: DaLao
 * @LastEditTime: 2021-12-25 03:21:37
-->

## 朴素算法

```c
bool isPrime(int n){
    for(int i = 2; i * i < n; i++){
        if(n % i == 0){
            return false;
        }
    }
    return true;
}
```

## 埃拉托斯特尼筛法

从2开始，将每个质数的倍数都标记成合数

![](https://cdn.hurra.ltd/img/20211124231756.png)

```c
// 求2-n之间的所有素数
const int n = 100;

// 标记所有数为素数
bool is_prime[n+1] = {true};

int prime[n];

int index = 0;

// 所有大于2的偶数均不是素数
for(int i = 4; i <= n; i+2){
    is_prime[i] = false;
}

for(int i = 2; i <= n; i++){
    // 某个奇数为素数
    if(is_prime[i]){
        prime[index++] = i;
        // 则它的倍数均不是素数
        for(int j = 2 * i;j < n; j +=i){
            is_prime[j] = false;
        }
    }
}
```

## 欧拉筛

用最小质因子来筛选，确保每个合数只被筛选一次

```c++
// 求2-n之间的所有素数
const int n = 100;

bool is_prime[n+1] = {true};

int prime[n];

int index = 0;

for(int i = 2; i <= n; i++){
    // 某个数为素数
    if(is_prime[i]){
        prime[index++] = i;
    }
    for(int j = 0; j <= index && i * prime[j] <= n; j++){
		is_prime[i * prime[j]] = false;
        // 若i是prime[j]的倍数，当i = k * prime[j+1]时会重复
		if (i % prime[j] == 0){
            break;
        }
	}
}
```

![](https://cdn.hurra.ltd/img/20211125002542.png)