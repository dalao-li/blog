<!--
 * @Description: 
 * @Version: 1.0
 * @Author: DaLao
 * @Email: dalao_li@163.com
 * @Date: 2021-03-30 11:54:45
 * @LastEditors: dalao
 * @LastEditTime: 2022-04-07 23:23:24
-->

## 文件访问


### 文件描述符

文件描述符`fd`(file descriptor)，是指向某个文件的符号，可通过它访问打开的文件或设备

程序开始运行时，一般会有三个打开的文件描述符

| 种类  | 缩写   | 描述         | 默认指向 |
| ----- | ------ | ------------ | -------- |
| `fd0` | stdin  | 标准输入     | 键盘     |
| `fd1` | stdout | 标准输出     | 屏幕     |
| `fd2` | stderr | 标准错误输出 | 屏幕     |

用户和计算机交互的本质是输入和输出，用户通过输入命令告诉计算机要做的操作，计算机处理后通过屏幕打印或输出文件告知用户

Linux命令处理可描述为

```sh
fd[输入文件]->命令->fd[输出文件]
```

如 ls ，默认输入文件是键盘，输出文件是屏幕


#### 重定向

重定向可改变文件描述符`fd`所指向的文件

| 方向       | 符号        |
| ---------- | ----------- |
| 输入重定向 | `<` 和 `<<` |
| 输出重定向 | `>` 和 `>>` |

```sh
echo "666" > a.txt

# fd作为标准输出可以省略，上命令可写为
echo "666" 1> a.txt
```

echo本是`fd1`(标准输出)，默认指向屏幕，经重定向后`fd1`指向a.txt，字符输出到此文件

![](https://cdn.hurra.ltd/img/20220220144913.png)


- 通过输出重定向丢弃信息

```sh
for i in {1..254};do
    ip="192.168.1.${i}"
    # 将标准/错误输出全部重定向到/dev/null中(丢弃产生的所有信息)
    ping -c 2 ${ip} > /dev/null &
done
```

## 系统调用


### write

write把缓冲区buf的前nbytes个字节写入到与文件描述符fd关联的文件中，返回实际写入的字节数

```c
#include<unistd.h>

size_t write(int fildes , const void *buf , size_t nbytes);
```

| 情况       | 返回值           |
| ---------- | ---------------- |
| 正常写入   | 实际写入的字节数 |
| 未写入数据 | 0                |
| 调用错误   | -1               |


```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

int main(void) {
    int length = write(1 , "Here is some data\n" , 18);
    if(length != 18) {
        write(2 , "A write error has occurred on file descriptor 1 \n" , 46);
    }
    return 0;
}
```

屏幕打印

```c
Here is some data
```


### read

```c
#include<unistd.h>

size_t read(int fildes , void *buf , size_t nbytes);
```

从文件描述符fildes相关联的文件里读入nbytes个字节的数据，并放到数据区buf中

| 情况                       | 返回值           |
| -------------------------- | ---------------- |
| 正常写入                   | 实际读入的字节数 |
| 未读入数据，已经到达文件尾 | 0                |
| 调用错误                   | -1               |

```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

int main(void) {
    char buffer[128];
    int nread;
    int nwrite;

    nread = read(0 , buffer , 128);
    if(nread == -1) {
        write(2 , "A read error has occurred\n" , 26);
    }

    nwrite = write(1 , buffer , nread);
    if(nwrite != nread) {
        write(2 , "A write error has occurred\n" , 27);
    }
    return 0;
}
```

```sh
# 键盘输入
Hello World!

# 屏幕输出
Hello World!
```


### open

```c
#include<fcntl.h>
#include<sys/types.h>
#include<sys/stat.h>

int open(const char *path , int oflags);
int open(const char *path , int oflags , mode_t mode);
```

创建新的文件描述符

调用成功后返回可以被read，write和其他系统调用那个使用的文件描述符

- oflags参数

| 模式     | 说明         |
| -------- | ------------ |
| O_RDONLY | 只读方式打开 |
| O_WRONLY | 只写方式打开 |
| O_RDWR   | 读写方式打开 |

测试程序

```c
#include<unistd.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<stdlib.h>

int main(void) {
    char block[1024];
    int in;
    int out;
    int nread;

    in = open("file.in" , O_RDONLY);
    out = open("file.out" , O_WRONLY|O_CREAT , S_IRUSR|S_IWUSR);
    while((nread = read(in , block , sizeof(block))) > 0) {
        write(out , block , nread);
    }
    return 0;
}
```
