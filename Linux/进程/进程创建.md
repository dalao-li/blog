<!--
 * @Description: 
 * @Version: 1.0
 * @Author: DaLao
 * @Email: dalao_li@163.com
 * @Date: 2021-11-11 21:53:16
 * @LastEditors: DaLao
 * @LastEditTime: 2021-11-11 22:16:43
-->

## 系统初始化

当启动操作系统时，通常会创建很多进程，有些是同用户交互并替他们完成工作的前台进程，其它都是后台进程，后台进程和特定用户没有关系，但也提供某些专门的功能，例如接收邮件等，这种功能的进程也称为守护进程

计划任务是个典型的守护进程，它每分钟运行一次来检查是否有工作需要它完成，若有工作要做，它就会完成此工作，然后进入休眠状态，直到下一次检查时刻的到来

正在运行的程序执行了创建进程的系统调用，在一个进程中又创建了一个新的进程，这种情况很常见

## 用户请求创建一个新进程

双击某个应用图标时，就会有至少一个进程被创建

在UNIX系统中，只有fork系统调用才可以创建新进程

```c
#include <stdio.h>
#include <unistd.h>

int main(void) {
    pid_t id = fork();
    
    if (id < 0) {
        perror("fork\n");
    // 子进程
    } else if (id == 0) {  
        printf("子进程\n");
    // 父进程
    } else {  
       printf("父进程\n");
   }
   return 0;
}
```

进程创之后，父子进程都有各自不同的地址空间，其中一个进程在其地址空间的修改对另一个进程不可见

子进程的初始化空间是父进程的一个副本，这里涉及两个不同地址空间，不可写的内存区是共享的，某些UNIX的实现使程序正文在两者间共享，因为它是不可修改的。

还有一种写时复制共享技术，子进程共享父进程的所有内存，一旦两者之一想要修改部分内存，则这块内存被复制确保修改发生在当前进程的私有内存区域。

