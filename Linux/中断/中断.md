<!--
 * @Description: 
 * @Version: 1.0
 * @Author: daLao
 * @Email: dalao@xxx.com
 * @Date: 2022-10-31 23:21:21
 * @LastEditors: daLao
 * @LastEditTime: 2022-11-08 00:44:38
-->

## 中断


### 定义


中断是指 **CPU** 对系统发生某事件时，暂停正在执行的程序，在保留现场后自动地转去执行该事件的中断处理程序，执行完后，再返回到原程序的断点处继续执行的一种响应


### 流程

发生异常（exception）和中断（interrupt）事件后，系统将进入 OS 内核态对相应事件进行处理

![img](https://cdn.hurra.ltd/img/15548795-d093d71c7521fe93.png)


### 类别


#### 外中断

指**中断**，是指由于**外部设备事件**所引起的中断，如通常的磁盘中断、打印机中断等

中断则是由于系统中某事件引起的，该事件与现行指令无关


#### 内中断

指**异常**，是指由于 **CPU 内部事件**所引起的中断，如程序出错(非法指令、地址越界)，也被译为“捕获”或“陷入”

异常是由于执行了现行指令所引起的。由于系统调用引起的中断属于异常


![img](https://cdn.hurra.ltd/img/20190328033536613.png)


### 对比

- 相同点

都是CPU对系统发生的某个事情做出的一种反应，最后都是由CPU发送给内核，由内核去处理

- 区别	

| 分类               | 中断                                                  | 异常                        |
| ------------------ | ----------------------------------------------------- | --------------------------- |
| 产生地点           | 处理器外部，由与运行程序无关的中断信号触发            | 处理器内部，CPU控制单元产生 |
| 能否被屏蔽         | 高优先级中断可屏蔽低优先级中断                        | 不可被屏蔽                  |
| 处理程序能否被阻塞 | 不能被阻塞，处理器休要即使响应中断信号                | 可以被阻塞                  |
| CPU                | 与CPU异步，无论处理器处于什么状态都需处理外部中断请求 | 与CPU异步                   |
| 能否嵌套           | 允许嵌套，一般不超过三重                              | 大多为一重                  |
| 相互之间影响       | 中断过程不会产生异常                                  | 异常处理过程中可能产生中断  |



### 中断


#### 分类

- 可屏蔽中断

I/O设备发出的所有中断请求(IRQ)都产生可屏蔽中断

通过 INTR（中断请求信号，高电平有效）向 CPU 请求，可通过设置屏蔽字来屏蔽请求

若中断请求被屏蔽，则不会被送到CPU

- 非屏蔽中断

危急时机，如硬件故障引起，由CPU辨认，通过 NMI （不可中断信号）向 CPU 请求

一旦产生，就被立即送 CPU以便快速处理，中断服务程序会尽快保存系统重要信息，然后在屏幕上显示相应的消息或直接重启系统

![img](https://cdn.hurra.ltd/img/15548795-b1a5ebeda01f0656.png)



#### 示例

- 网卡中断

1. 数据到达网卡；

2. 网卡产生一个中断给内核；

3. 内核使用I/O指令，从网卡I/O区域中去读取数据；



### 异常


#### 分类

- 故障

执行指令引起的异常，如缺页、越权、越级、溢出、非法指令，断点为故障发生的地方

- 陷阱

预先安排的事件，如调试程序时打的断点，单步跟踪，系统调用，是一种自愿中断，断点为自陷指令的下一条指令

- 终止

不可恢复的错误，如硬件故障事件，此时机器会终止，调出中断服务程序来终止程序甚至重启操作系统


#### 示例

- 除零异常

当系统返现除零时，会抛出异常，如果程序不处理这个异常，那么操作系统将发出一个异步信号终止当前执行的程序



### 概念


#### 中断向量

每个异常和中断由0~255间的数标识，称为中断向量（vector）


#### 中断向量表 

存放中断向量到中断执行程序地址的映射

部分映射需在内核初始化开启中断前完成设置，也能够后续执行过程中动态修改与添加映射

![img](https://cdn.hurra.ltd/img/188548-12c77d95190862af.png)


![img](https://cdn.hurra.ltd/img/188548-47a19e4dfd8146dc.png)

#### 中断执行程序

中断向量对应的执行程序，用于执行具体中断逻辑，需用户自定义



#### 中断执行流程

CPU在执行过程中，触发中断，而后CPU根据触发中断携带的中断向量，从中断向量表中找出中断执行程序，跳转执行中断执行程序，执行完成再跳回中断前程序执行


### 中断处理流程


#### 准备

- 保护现场

将各寄存器的内容压入堆栈保存

- 判断中断

是否能够中断切换

- 开中断

允许高级版中断，实现中断嵌套


#### 执行

- 中断处理

跳转到中断处理代码处

中断控制器中有一个中断优先级判别器，它自动判别出目前提出中断请求的优先级最高的中断源，并将它的中断向量码送到数据总线，CPU接收中断向量码并据此找到它的中断服务程序


#### 收尾

- 关中断

保护恢复现场过程

- 恢复现场

将保存在堆栈中的现场信息弹出到原来的寄存器中

- 开中断

响应下一次中断


### 代码演示


```c++
#include <iostream>
#include <csignal>
#include <unistd.h>

void signalHandler(int signum)
{
    std::cout << "中断信号 (" << signum << ") 被捕获." << std::endl;
    exit(signal);
}

int main()
{
    // 注册信号SIGNAL(交互的用户按键请求) 和信号处理程序
    signal(SIGINT, signalHandler);

    while (1)
    {
        std::cout << "Going to sleep..." << std::endl;
        sleep(1);
    }

    return 0;
}
```

在按下Ctrl + C结束程序时，系统产生了中断信号kill -s INT然后发给程序, 程序捕捉到了 signal number = 2的信号