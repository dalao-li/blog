<!--
 * @Description: 
 * @Version: 1.0
 * @Author: dalao
 * @Email: dalao_li@163.com
 * @Date: 2023-02-28 22:32:19
 * @LastEditors: daLao
 * @LastEditTime: 2023-04-17 16:02:52
-->

# 动态库

Linxu下为`so`, Windows下为`dll`

## 创建

可使用编译器即可创建动态库

```shell
g++ *.cpp -fPIC -shared -o *.so
```

- fPIC

创建与地址无关的编译程序 (pic, position independent code),为了能够在多个应用程序间共享

- shared

此选项将尽量使用动态库.所以生成文件较小, 但需要系统动态库

TestAPI.h

```c++
#include <iostream>

#ifndef INCLUDE_TESTAPI_H
#define INCLUDE_TESTAPI_H

#ifdef __cplusplus
extern "C" {
#endif

void display();

int add(int x, int y);

#ifdef __cplusplus
}
#endif

#endif
```

TestAPI.cpp

```c
#include "TestAPI.h"

void display() {
    std::cout << "Test Success!" << std::endl;
}

int add(int x, int y) {
    return x + y;
}
```

- Linux

```sh
g++ TestAPI.cpp -fPIC -shared -o libTestAPI.so
```

若报找不到库文件错误, 移动动态库到/usr/lib目录

```c
sudo mv libTest.so /usr/lib
```

- Windows

Windows 下函数前添加 \_\_declspec(dllexport)的来说明是动态库导出

```c++
#include <iostream>

#ifndef INCLUDE_TESTAPI_H
#define INCLUDE_TESTAPI_H

#ifdef __cplusplus
extern "C" {
#endif

__declspec(dllexport) void display();

__declspec(dllexport) int add(int x, int y);

#ifdef __cplusplus
}
#endif

#endif
```

指令与Linux下类似, 生成动态库名称后缀为.dll

```sh
g++ TestAPI.cpp -fPIC -shared -o libTestAPI.dll
```

## 调用

### 头文件引用

例如上面由TestAPI.h 与TestAPI.cpp 生成的动态库, 可直接引用头文件来调用

Main.cpp

```c++
#include "TestAPI.h"

int main(void) {
    display();

    std::cout << "add = " << add(1, 2) << std::endl;
}
```

### 动态库读取
